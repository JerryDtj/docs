# 深入理解jvm——3.2 对象已死吗

## 如何判定一个对象是否可以被回收之算法篇

### 3.2.1引用计数法——简单高效但是没有采用

​	给对象添加一个计数器,每当有一个地方引用时,计数器加一,当引用失效时,计数器减一.任何时刻计数器为0 的对象就是不可能再被使用的.

​	jvm中没有采用该算法,原因是无法解决对象之间相互循环引用的问题.

### 3.2.2可达性分析算法——jvm回收采用算法

​	通过一系列的“GC ROOT”的对象作为起点,每一个对象关联GC ROOT时,就在引用链上增加一个节点.当一个对象没有GC ROOT相关联时(GC ROOT不可达),那么就认为这个对象时可以回收的.

​	java中可做GC ROOT的对象包含以下几种:

- 虚拟机栈(栈帧中的本地变量表)中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI(即一般说的Native方法)引用的对象

### 如何判断一个对象是否引用——java的四种引用

- 强引用
- 软引用
- 弱引用
- 虚引用

### 不可达就一定会被回收吗——对象自救篇

一个对象在被回收时,至少要经历2次标记过程:

1.判断对象不可达后,被第一次标记.并进行一次筛选.筛选条件为是否有必要执行Finalize().如果对象没有finalize(),或者finalize()已经被调用过.虚拟机将这两种情况都视为没有必要执行.

2.如果判定为有必要执行finalize().那么会将这个对象放置到F-Queue队列中.然后机会对队列中的对象在次标记并清理.

注意:**Finalize()只会执行一遍,而且jvm不保证finalize()一定会执行**.

### 回收方法区

类需要满足下面的3个条件才能算是**可能被回收**:

1. 该类的所有实例都已经被回收,也就是java堆中不存在该类的任何实例
2. 加载该类的classLoader已经被回收
3. 该类对应的java.lang.Class对象没有在任何地方被引用,无法在任何地方通过反射访问该类的方法

### 垃圾回收算法

标记——清除算法:使用过的内存做标记,只清楚标记的.会照成内存不连续

复制算法:每次都只用一半内存,清理时,用另外一半内存.

标记整理算法:每次使用都标记.然后整理内存.

分代收集算法:按照不同的内存,用不同的算法机制.

### JVM的算法实现

1.做gc回收的时候,系统一定是暂停状态的.

2.只有在安全点内或者安全区域(线程处于Sleep或者blocked状态),才会通过OopMap找到Gc Root,从而内存回收.

